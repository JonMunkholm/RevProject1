package pages

import (
    "fmt"
    "net/url"
    "strconv"
    "strings"
    "time"

    "github.com/JonMunkholm/RevProject1/app/layout"
)

type ChatProvider struct {
    ID    string
    Label string
}

type ChatMessageView struct {
    ID        string
    Role      string
    Content   string
    CreatedAt time.Time
}

type ChatConversationView struct {
    ID            string
    Title         string
    Preview       string
    ProviderID    string
    ProviderLabel string
    UpdatedAt     time.Time
    IsActive      bool
}

type ChatConversationChunkProps struct {
    Conversations          []ChatConversationView
    NextOffset             int
    HasMore                bool
    ActiveConversationID   string
    ActiveProviderID       string
}

type ChatPageProps struct {
    Providers              []ChatProvider
    ActiveProviderID       string
    ActiveProviderLabel    string
    ConversationID         string
    Messages               []ChatMessageView
    BlockedReason          string
    ErrorMessage           string
    Conversations          []ChatConversationView
    ConversationsNextOffset int
    ConversationsHasMore    bool
}

type ChatTranscriptProps struct {
    ConversationID string
    Messages       []ChatMessageView
    BlockedReason  string
    ErrorMessage   string
}

templ ChatPage(props ChatPageProps) {
    @layout.LayoutWithAssets(
        "Chat",
        []string{
            "/assets/css/settings.css",
            "/assets/css/chat.css",
        },
        ChatShell(props),
    )
}

templ ChatShell(props ChatPageProps) {
    <div class="chat-layout" id="chat-root">
        <aside class="chat-layout__sidebar">
            <section class="chat-sidebar-section">
                <header class="chat-layout__sidebar-header">
                    <h2>Provider</h2>
                    <p>Select a provider to control this conversation.</p>
                </header>
                if len(props.Providers) == 0 {
                    <p class="chat-layout__empty">No providers available. Add credentials in Settings → AI.</p>
                } else {
                    <ul class="chat-provider-list">
                        for _, provider := range props.Providers {
                            <li class={chatProviderClasses(provider.ID == props.ActiveProviderID)}>
                                <button
                                    type="button"
                                    hx-post="/app/chat/conversations"
                                    hx-target="#chat-root"
                                    hx-swap="outerHTML"
                                    hx-encoding="json"
                                    hx-vals={fmt.Sprintf("{\"provider\":\"%s\"}", provider.ID)}
                                    hx-push-url={fmt.Sprintf("/app/chat?provider=%s", provider.ID)}
                                >
                                    {provider.Label}
                                </button>
                            </li>
                        }
                    </ul>
                }
            </section>
            @ChatConversationList(props)
        </aside>
        <section class="chat-layout__main">
            <header class="chat-layout__main-header">
                <div>
                    <h1>{props.ActiveProviderLabel}</h1>
                    if props.BlockedReason != "" {
                        <p class="chat-layout__notice">{props.BlockedReason}</p>
                    }
                </div>
                <div class="chat-layout__actions">
                    <button
                        type="button"
                        class="chat-button chat-button--ghost"
                        hx-post="/app/chat/conversations"
                        hx-target="#chat-root"
                        hx-swap="outerHTML"
                        hx-encoding="json"
                        hx-vals={fmt.Sprintf("{\"provider\":\"%s\"}", props.ActiveProviderID)}
                    >
                        New conversation
                    </button>
                </div>
            </header>
            <div id="chat-transcript">
                @ChatTranscript(ChatTranscriptProps{
                    ConversationID: props.ConversationID,
                    Messages: props.Messages,
                    BlockedReason: props.BlockedReason,
                    ErrorMessage: props.ErrorMessage,
                })
            </div>
        </section>
    </div>
}

templ ChatConversationList(props ChatPageProps) {
    <section class="chat-sidebar-section chat-sidebar-section--conversations">
        <header class="chat-layout__sidebar-header">
            <h2>Recent conversations</h2>
            <p>Resume a previous chat or start a new one.</p>
        </header>
        if len(props.Conversations) == 0 {
            <p class="chat-layout__empty">No conversations yet. Send a message to create one.</p>
        } else {
            <ol class="chat-conversation-list" id="chat-conversation-list">
                for _, conv := range props.Conversations {
                    @ChatConversationListItem(conv)
                }
                if props.ConversationsHasMore {
                    @ChatConversationSentinel(props.ConversationsNextOffset, props.ActiveProviderID, props.ConversationID)
                }
            </ol>
            <div id="chat-conversation-loading" class="chat-conversation-list__loading htmx-indicator" aria-live="polite">
                Loading more conversations…
            </div>
        }
    </section>
}

templ ChatConversationItems(props ChatConversationChunkProps) {
    for _, conv := range props.Conversations {
        @ChatConversationListItem(conv)
    }
    if props.HasMore {
        @ChatConversationSentinel(props.NextOffset, props.ActiveProviderID, props.ActiveConversationID)
    }
}

templ ChatConversationListItem(conv ChatConversationView) {
    <li class={chatConversationItemClasses(conv.IsActive)}>
        <a
            class="chat-conversation"
            href={conversationPushURL(conv.ProviderID, conv.ID)}
            hx-get={conversationLoadURL(conv.ID, conv.ProviderID)}
            hx-target="#chat-root"
            hx-swap="outerHTML"
            hx-push-url={conversationPushURL(conv.ProviderID, conv.ID)}
        >
            <span class="chat-conversation__title">{conv.Title}</span>
            <span class="chat-conversation__meta">{conversationMeta(conv.ProviderLabel, conv.UpdatedAt)}</span>
            if conv.Preview != "" {
                <p class="chat-conversation__preview">{conv.Preview}</p>
            }
        </a>
    </li>
}

templ ChatConversationSentinel(offset int, providerID, conversationID string) {
    <li class="chat-conversation-list__sentinel">
        <button
            type="button"
            class="chat-conversation-list__load-more"
            hx-get={conversationListURL(offset, providerID, conversationID)}
            hx-trigger="revealed once, click"
            hx-target="#chat-conversation-list"
            hx-swap="beforeend"
            hx-indicator="#chat-conversation-loading"
            hx-on::after-request="this.closest('li').remove()"
        >
            Load more conversations
        </button>
    </li>
}

templ ChatTranscript(props ChatTranscriptProps) {
    <div class="chat-transcript">
        if props.ErrorMessage != "" {
            <div class="chat-transcript__notice chat-transcript__notice--error" role="alert">
                {props.ErrorMessage}
            </div>
        }
        if len(props.Messages) == 0 {
            <div class="chat-transcript__empty">
                <p>Start the conversation by sending a message.</p>
            </div>
        } else {
            <ol class="chat-transcript__list">
                for _, msg := range props.Messages {
                    <li class={chatMessageClasses(msg.Role)}>
                        <div class="chat-message__meta">
                            <span class="chat-message__role">{displayRole(msg.Role)}</span>
                            <span class="chat-message__time">{msg.CreatedAt.Format("15:04")}</span>
                        </div>
                        <div class="chat-message__content">
                            <p>{msg.Content}</p>
                        </div>
                    </li>
                }
            </ol>
        }

        if props.BlockedReason != "" {
            <div class="chat-transcript__notice" role="alert">
                {props.BlockedReason}
            </div>
        } else if props.ConversationID != "" {
            <form
                class="chat-composer"
                hx-post={fmt.Sprintf("/app/chat/conversations/%s/messages", props.ConversationID)}
                hx-target="#chat-transcript"
                hx-swap="outerHTML"
                hx-encoding="json"
                hx-on::after-request="this.reset()"
                hx-trigger="submit from:#chat-input"
                hx-on::init="this.addEventListener('keydown', (event) => { if (event.key === 'Enter' && !event.shiftKey && event.target.id === 'chat-input') { event.preventDefault(); htmx.trigger(this, 'submit'); } });"
            >
                <label class="chat-composer__label" for="chat-input">Message</label>
                <textarea
                    id="chat-input"
                    name="content"
                    required
                    rows="3"
                    placeholder="Ask a question or type a prompt..."
                ></textarea>
                <div class="chat-composer__actions">
                    <button type="submit" class="chat-button">Send</button>
                </div>
            </form>
        }
    </div>
}

func chatConversationItemClasses(active bool) string {
    if active {
        return "chat-conversation-list__item chat-conversation-list__item--active"
    }
    return "chat-conversation-list__item"
}

func conversationLoadURL(conversationID, providerID string) string {
    if strings.TrimSpace(providerID) == "" {
        return fmt.Sprintf("/app/chat/conversations/%s", conversationID)
    }
    return fmt.Sprintf("/app/chat/conversations/%s?provider=%s", conversationID, url.QueryEscape(providerID))
}

func conversationPushURL(providerID, conversationID string) string {
    values := url.Values{}
    if strings.TrimSpace(providerID) != "" {
        values.Set("provider", providerID)
    }
    if strings.TrimSpace(conversationID) != "" {
        values.Set("conversation", conversationID)
    }
    if len(values) == 0 {
        return "/app/chat"
    }
    return "/app/chat?" + values.Encode()
}

func conversationListURL(offset int, providerID, conversationID string) string {
    if offset < 0 {
        offset = 0
    }
    values := url.Values{}
    values.Set("offset", strconv.Itoa(offset))
    if strings.TrimSpace(providerID) != "" {
        values.Set("provider", providerID)
    }
    if strings.TrimSpace(conversationID) != "" {
        values.Set("active", conversationID)
    }
    encoded := values.Encode()
    if encoded == "" {
        return "/app/chat/conversations"
    }
    return "/app/chat/conversations?" + encoded
}

func conversationMeta(providerLabel string, updated time.Time) string {
    label := strings.TrimSpace(providerLabel)
    if label == "" {
        label = "Conversation"
    }
    timestamp := formatConversationTimestamp(updated)
    if timestamp == "" {
        return label
    }
    return fmt.Sprintf("%s · %s", label, timestamp)
}

func formatConversationTimestamp(ts time.Time) string {
    if ts.IsZero() {
        return ""
    }
    return ts.Local().Format("Jan 2, 15:04")
}

func chatProviderClasses(active bool) string {
    if active {
        return "chat-provider-list__item chat-provider-list__item--active"
    }
    return "chat-provider-list__item"
}

func chatMessageClasses(role string) string {
    switch role {
    case "assistant":
        return "chat-message chat-message--assistant"
    case "system":
        return "chat-message chat-message--system"
    default:
        return "chat-message chat-message--user"
    }
}

func displayRole(role string) string {
    switch strings.ToLower(role) {
    case "assistant":
        return "Assistant"
    case "system":
        return "System"
    default:
        return "You"
    }
}
