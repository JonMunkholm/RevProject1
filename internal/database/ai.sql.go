// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ai.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const deleteAIProviderCredential = `-- name: DeleteAIProviderCredential :exec
DELETE FROM ai_provider_credentials
WHERE company_id = $1
  AND user_id    = $2
  AND provider_id = $3
`

type DeleteAIProviderCredentialParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
}

func (q *Queries) DeleteAIProviderCredential(ctx context.Context, arg DeleteAIProviderCredentialParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIProviderCredential, arg.CompanyID, arg.UserID, arg.ProviderID)
	return err
}

const deleteAIUserPreference = `-- name: DeleteAIUserPreference :exec
DELETE FROM ai_user_preferences
WHERE company_id = $1
  AND user_id    = $2
`

type DeleteAIUserPreferenceParams struct {
	CompanyID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) DeleteAIUserPreference(ctx context.Context, arg DeleteAIUserPreferenceParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIUserPreference, arg.CompanyID, arg.UserID)
	return err
}

const getAIProviderCredential = `-- name: GetAIProviderCredential :one
SELECT id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at
FROM ai_provider_credentials
WHERE company_id = $1
  AND user_id    = $2
  AND provider_id = $3
`

type GetAIProviderCredentialParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
}

func (q *Queries) GetAIProviderCredential(ctx context.Context, arg GetAIProviderCredentialParams) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, getAIProviderCredential, arg.CompanyID, arg.UserID, arg.ProviderID)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
	)
	return i, err
}

const getAIUserPreference = `-- name: GetAIUserPreference :one
SELECT user_id, company_id, provider_id, model, metadata, updated_at
FROM ai_user_preferences
WHERE company_id = $1
  AND user_id    = $2
`

type GetAIUserPreferenceParams struct {
	CompanyID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) GetAIUserPreference(ctx context.Context, arg GetAIUserPreferenceParams) (AiUserPreference, error) {
	row := q.db.QueryRowContext(ctx, getAIUserPreference, arg.CompanyID, arg.UserID)
	var i AiUserPreference
	err := row.Scan(
		&i.UserID,
		&i.CompanyID,
		&i.ProviderID,
		&i.Model,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAIProviderCredential = `-- name: InsertAIProviderCredential :one
INSERT INTO ai_provider_credentials (
    company_id,
    user_id,
    provider_id,
    credential_cipher,
    credential_hash,
    metadata
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, '{}'::jsonb)
)
RETURNING id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at
`

type InsertAIProviderCredentialParams struct {
	CompanyID        uuid.UUID
	UserID           uuid.UUID
	ProviderID       string
	CredentialCipher []byte
	CredentialHash   []byte
	Column6          interface{}
}

func (q *Queries) InsertAIProviderCredential(ctx context.Context, arg InsertAIProviderCredentialParams) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, insertAIProviderCredential,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.CredentialCipher,
		arg.CredentialHash,
		arg.Column6,
	)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
	)
	return i, err
}

const insertAIToolInvocation = `-- name: InsertAIToolInvocation :exec
INSERT INTO ai_tool_invocations (
    user_id,
    provider_id,
    tool_name,
    status,
    request,
    response,
    error_message
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, 'success'),
    $5,
    $6,
    $7
)
`

type InsertAIToolInvocationParams struct {
	UserID       uuid.NullUUID
	ProviderID   string
	ToolName     string
	Column4      interface{}
	Request      pqtype.NullRawMessage
	Response     pqtype.NullRawMessage
	ErrorMessage sql.NullString
}

func (q *Queries) InsertAIToolInvocation(ctx context.Context, arg InsertAIToolInvocationParams) error {
	_, err := q.db.ExecContext(ctx, insertAIToolInvocation,
		arg.UserID,
		arg.ProviderID,
		arg.ToolName,
		arg.Column4,
		arg.Request,
		arg.Response,
		arg.ErrorMessage,
	)
	return err
}

const listAIToolInvocationsByProvider = `-- name: ListAIToolInvocationsByProvider :many
SELECT id, user_id, provider_id, tool_name, status, request, response, error_message, created_at
FROM ai_tool_invocations
WHERE provider_id = $1
  AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type ListAIToolInvocationsByProviderParams struct {
	ProviderID  string
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) ListAIToolInvocationsByProvider(ctx context.Context, arg ListAIToolInvocationsByProviderParams) ([]AiToolInvocation, error) {
	rows, err := q.db.QueryContext(ctx, listAIToolInvocationsByProvider, arg.ProviderID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiToolInvocation
	for rows.Next() {
		var i AiToolInvocation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.ToolName,
			&i.Status,
			&i.Request,
			&i.Response,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIToolInvocationsByUser = `-- name: ListAIToolInvocationsByUser :many
SELECT id, user_id, provider_id, tool_name, status, request, response, error_message, created_at
FROM ai_tool_invocations
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAIToolInvocationsByUserParams struct {
	UserID uuid.NullUUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListAIToolInvocationsByUser(ctx context.Context, arg ListAIToolInvocationsByUserParams) ([]AiToolInvocation, error) {
	rows, err := q.db.QueryContext(ctx, listAIToolInvocationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiToolInvocation
	for rows.Next() {
		var i AiToolInvocation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.ToolName,
			&i.Status,
			&i.Request,
			&i.Response,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchAIProviderCredential = `-- name: TouchAIProviderCredential :exec
UPDATE ai_provider_credentials
SET last_used_at = now(),
    updated_at   = now()
WHERE company_id = $1
  AND user_id    = $2
  AND provider_id = $3
`

type TouchAIProviderCredentialParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
}

func (q *Queries) TouchAIProviderCredential(ctx context.Context, arg TouchAIProviderCredentialParams) error {
	_, err := q.db.ExecContext(ctx, touchAIProviderCredential, arg.CompanyID, arg.UserID, arg.ProviderID)
	return err
}

const updateAIProviderCredential = `-- name: UpdateAIProviderCredential :one
UPDATE ai_provider_credentials
SET
    credential_cipher = $3,
    credential_hash   = $4,
    metadata          = COALESCE($5, metadata),
    updated_at        = now(),
    rotated_at        = now()
WHERE company_id = $1
  AND user_id    = $2
  AND provider_id = $6
RETURNING id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at
`

type UpdateAIProviderCredentialParams struct {
	CompanyID        uuid.UUID
	UserID           uuid.UUID
	CredentialCipher []byte
	CredentialHash   []byte
	Metadata         json.RawMessage
	ProviderID       string
}

func (q *Queries) UpdateAIProviderCredential(ctx context.Context, arg UpdateAIProviderCredentialParams) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, updateAIProviderCredential,
		arg.CompanyID,
		arg.UserID,
		arg.CredentialCipher,
		arg.CredentialHash,
		arg.Metadata,
		arg.ProviderID,
	)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
	)
	return i, err
}

const upsertAIUserPreference = `-- name: UpsertAIUserPreference :one
INSERT INTO ai_user_preferences (company_id, user_id, provider_id, model, metadata)
VALUES ($1, $2, $3, $4, COALESCE($5, '{}'::jsonb))
ON CONFLICT (company_id, user_id) DO UPDATE
SET provider_id = EXCLUDED.provider_id,
    model       = EXCLUDED.model,
    metadata    = EXCLUDED.metadata,
    updated_at  = now()
RETURNING user_id, company_id, provider_id, model, metadata, updated_at
`

type UpsertAIUserPreferenceParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
	Model      sql.NullString
	Column5    interface{}
}

func (q *Queries) UpsertAIUserPreference(ctx context.Context, arg UpsertAIUserPreferenceParams) (AiUserPreference, error) {
	row := q.db.QueryRowContext(ctx, upsertAIUserPreference,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.Model,
		arg.Column5,
	)
	var i AiUserPreference
	err := row.Scan(
		&i.UserID,
		&i.CompanyID,
		&i.ProviderID,
		&i.Model,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}
