// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ai.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const clearDefaultAIProviderCredentials = `-- name: ClearDefaultAIProviderCredentials :exec
UPDATE ai_provider_credentials
SET is_default = false,
    updated_at = now()
WHERE company_id = $1
  AND provider_id = $2
  AND (
    ($3 IS NULL AND user_id IS NULL)
    OR ($3 IS NOT NULL AND user_id IS NOT DISTINCT FROM $3)
  )
`

type ClearDefaultAIProviderCredentialsParams struct {
	CompanyID  uuid.UUID
	ProviderID string
	UserID     interface{}
}

func (q *Queries) ClearDefaultAIProviderCredentials(ctx context.Context, arg ClearDefaultAIProviderCredentialsParams) error {
	_, err := q.db.ExecContext(ctx, clearDefaultAIProviderCredentials, arg.CompanyID, arg.ProviderID, arg.UserID)
	return err
}

const deleteAIProviderCredential = `-- name: DeleteAIProviderCredential :exec
DELETE FROM ai_provider_credentials
WHERE company_id = $1
  AND user_id IS NOT DISTINCT FROM $2
  AND provider_id = $3
`

type DeleteAIProviderCredentialParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.NullUUID
	ProviderID string
}

func (q *Queries) DeleteAIProviderCredential(ctx context.Context, arg DeleteAIProviderCredentialParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIProviderCredential, arg.CompanyID, arg.UserID, arg.ProviderID)
	return err
}

const deleteAIProviderCredentialByID = `-- name: DeleteAIProviderCredentialByID :exec
DELETE FROM ai_provider_credentials
WHERE id = $1
`

func (q *Queries) DeleteAIProviderCredentialByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAIProviderCredentialByID, id)
	return err
}

const deleteAIUserPreference = `-- name: DeleteAIUserPreference :exec
DELETE FROM ai_user_preferences
WHERE company_id = $1
  AND user_id    = $2
`

type DeleteAIUserPreferenceParams struct {
	CompanyID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) DeleteAIUserPreference(ctx context.Context, arg DeleteAIUserPreferenceParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIUserPreference, arg.CompanyID, arg.UserID)
	return err
}

const getAIProviderCredential = `-- name: GetAIProviderCredential :one
SELECT id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
FROM ai_provider_credentials
WHERE id = $1
`

func (q *Queries) GetAIProviderCredential(ctx context.Context, id uuid.UUID) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, getAIProviderCredential, id)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
		&i.Label,
		&i.IsDefault,
		&i.LastTestedAt,
		&i.Fingerprint,
	)
	return i, err
}

const getAIUserPreference = `-- name: GetAIUserPreference :one
SELECT user_id, company_id, provider_id, model, metadata, updated_at
FROM ai_user_preferences
WHERE company_id = $1
  AND user_id    = $2
`

type GetAIUserPreferenceParams struct {
	CompanyID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) GetAIUserPreference(ctx context.Context, arg GetAIUserPreferenceParams) (AiUserPreference, error) {
	row := q.db.QueryRowContext(ctx, getAIUserPreference, arg.CompanyID, arg.UserID)
	var i AiUserPreference
	err := row.Scan(
		&i.UserID,
		&i.CompanyID,
		&i.ProviderID,
		&i.Model,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAIProviderCredential = `-- name: InsertAIProviderCredential :one
INSERT INTO ai_provider_credentials (
    company_id,
    user_id,
    provider_id,
    credential_cipher,
    credential_hash,
    metadata,
    label,
    is_default,
    last_tested_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, '{}'::jsonb),
    $7,
    COALESCE($8, false),
    $9
)
RETURNING id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
`

type InsertAIProviderCredentialParams struct {
	CompanyID        uuid.UUID
	UserID           uuid.NullUUID
	ProviderID       string
	CredentialCipher []byte
	CredentialHash   []byte
	Metadata         interface{}
	Label            sql.NullString
	IsDefault        interface{}
	LastTestedAt     sql.NullTime
}

func (q *Queries) InsertAIProviderCredential(ctx context.Context, arg InsertAIProviderCredentialParams) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, insertAIProviderCredential,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.CredentialCipher,
		arg.CredentialHash,
		arg.Metadata,
		arg.Label,
		arg.IsDefault,
		arg.LastTestedAt,
	)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
		&i.Label,
		&i.IsDefault,
		&i.LastTestedAt,
		&i.Fingerprint,
	)
	return i, err
}

const insertAIProviderCredentialEvent = `-- name: InsertAIProviderCredentialEvent :exec
INSERT INTO ai_provider_credential_events (
    company_id,
    user_id,
    actor_user_id,
    provider_id,
    action,
    metadata_snapshot
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, '{}'::jsonb)
)
`

type InsertAIProviderCredentialEventParams struct {
	CompanyID        uuid.UUID
	UserID           uuid.NullUUID
	ActorUserID      uuid.NullUUID
	ProviderID       string
	Action           string
	MetadataSnapshot interface{}
}

func (q *Queries) InsertAIProviderCredentialEvent(ctx context.Context, arg InsertAIProviderCredentialEventParams) error {
	_, err := q.db.ExecContext(ctx, insertAIProviderCredentialEvent,
		arg.CompanyID,
		arg.UserID,
		arg.ActorUserID,
		arg.ProviderID,
		arg.Action,
		arg.MetadataSnapshot,
	)
	return err
}

const insertAIToolInvocation = `-- name: InsertAIToolInvocation :exec
INSERT INTO ai_tool_invocations (
    user_id,
    provider_id,
    tool_name,
    status,
    request,
    response,
    error_message
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, 'success'),
    $5,
    $6,
    $7
)
`

type InsertAIToolInvocationParams struct {
	UserID       uuid.NullUUID
	ProviderID   string
	ToolName     string
	Column4      interface{}
	Request      pqtype.NullRawMessage
	Response     pqtype.NullRawMessage
	ErrorMessage sql.NullString
}

func (q *Queries) InsertAIToolInvocation(ctx context.Context, arg InsertAIToolInvocationParams) error {
	_, err := q.db.ExecContext(ctx, insertAIToolInvocation,
		arg.UserID,
		arg.ProviderID,
		arg.ToolName,
		arg.Column4,
		arg.Request,
		arg.Response,
		arg.ErrorMessage,
	)
	return err
}

const listAIProviderCredentialEvents = `-- name: ListAIProviderCredentialEvents :many
SELECT id, company_id, user_id, actor_user_id, provider_id, action, metadata_snapshot, created_at
FROM ai_provider_credential_events
WHERE company_id = $1
  AND provider_id = $2
  AND (
    $3 IS NULL
    OR action = $3
  )
  AND (
    $4 IS NULL
    OR ($4 = 'company' AND user_id IS NULL)
    OR ($4 = 'user' AND user_id IS NOT NULL)
  )
  AND (
    $5 IS NULL
    OR actor_user_id = $5
  )
ORDER BY created_at DESC
LIMIT $7 OFFSET $6
`

type ListAIProviderCredentialEventsParams struct {
	CompanyID   uuid.UUID
	ProviderID  string
	Action      interface{}
	Scope       interface{}
	ActorUserID interface{}
	Offset      int32
	Limit       int32
}

func (q *Queries) ListAIProviderCredentialEvents(ctx context.Context, arg ListAIProviderCredentialEventsParams) ([]AiProviderCredentialEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAIProviderCredentialEvents,
		arg.CompanyID,
		arg.ProviderID,
		arg.Action,
		arg.Scope,
		arg.ActorUserID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProviderCredentialEvent
	for rows.Next() {
		var i AiProviderCredentialEvent
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ActorUserID,
			&i.ProviderID,
			&i.Action,
			&i.MetadataSnapshot,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIProviderCredentialsByCompany = `-- name: ListAIProviderCredentialsByCompany :many
SELECT id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
FROM ai_provider_credentials
WHERE company_id = $1
ORDER BY provider_id, user_id, is_default DESC, updated_at DESC
LIMIT $3 OFFSET $2
`

type ListAIProviderCredentialsByCompanyParams struct {
	CompanyID uuid.UUID
	Offset    int32
	Limit     int32
}

func (q *Queries) ListAIProviderCredentialsByCompany(ctx context.Context, arg ListAIProviderCredentialsByCompanyParams) ([]AiProviderCredential, error) {
	rows, err := q.db.QueryContext(ctx, listAIProviderCredentialsByCompany, arg.CompanyID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProviderCredential
	for rows.Next() {
		var i AiProviderCredential
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ProviderID,
			&i.CredentialCipher,
			&i.CredentialHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
			&i.RotatedAt,
			&i.Label,
			&i.IsDefault,
			&i.LastTestedAt,
			&i.Fingerprint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIProviderCredentialsByScope = `-- name: ListAIProviderCredentialsByScope :many
SELECT id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
FROM ai_provider_credentials
WHERE company_id = $1
  AND provider_id = $2
  AND (
    ($3 IS NULL AND user_id IS NULL)
    OR ($3 IS NOT NULL AND user_id IS NOT DISTINCT FROM $3)
  )
ORDER BY is_default DESC, updated_at DESC, created_at DESC
`

type ListAIProviderCredentialsByScopeParams struct {
	CompanyID  uuid.UUID
	ProviderID string
	UserID     interface{}
}

func (q *Queries) ListAIProviderCredentialsByScope(ctx context.Context, arg ListAIProviderCredentialsByScopeParams) ([]AiProviderCredential, error) {
	rows, err := q.db.QueryContext(ctx, listAIProviderCredentialsByScope, arg.CompanyID, arg.ProviderID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProviderCredential
	for rows.Next() {
		var i AiProviderCredential
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ProviderID,
			&i.CredentialCipher,
			&i.CredentialHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
			&i.RotatedAt,
			&i.Label,
			&i.IsDefault,
			&i.LastTestedAt,
			&i.Fingerprint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIProviderCredentialsForResolver = `-- name: ListAIProviderCredentialsForResolver :many
SELECT id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
FROM ai_provider_credentials
WHERE company_id = $1
  AND provider_id = $2
  AND (
    user_id IS NULL OR user_id = $3
  )
ORDER BY
  CASE WHEN user_id = $3 THEN 0 ELSE 1 END,
  is_default DESC,
  updated_at DESC,
  created_at DESC
`

type ListAIProviderCredentialsForResolverParams struct {
	CompanyID  uuid.UUID
	ProviderID string
	UserID     uuid.NullUUID
}

func (q *Queries) ListAIProviderCredentialsForResolver(ctx context.Context, arg ListAIProviderCredentialsForResolverParams) ([]AiProviderCredential, error) {
	rows, err := q.db.QueryContext(ctx, listAIProviderCredentialsForResolver, arg.CompanyID, arg.ProviderID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProviderCredential
	for rows.Next() {
		var i AiProviderCredential
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ProviderID,
			&i.CredentialCipher,
			&i.CredentialHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
			&i.RotatedAt,
			&i.Label,
			&i.IsDefault,
			&i.LastTestedAt,
			&i.Fingerprint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIToolInvocationsByProvider = `-- name: ListAIToolInvocationsByProvider :many
SELECT id, user_id, provider_id, tool_name, status, request, response, error_message, created_at
FROM ai_tool_invocations
WHERE provider_id = $1
  AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
`

type ListAIToolInvocationsByProviderParams struct {
	ProviderID  string
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

func (q *Queries) ListAIToolInvocationsByProvider(ctx context.Context, arg ListAIToolInvocationsByProviderParams) ([]AiToolInvocation, error) {
	rows, err := q.db.QueryContext(ctx, listAIToolInvocationsByProvider, arg.ProviderID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiToolInvocation
	for rows.Next() {
		var i AiToolInvocation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.ToolName,
			&i.Status,
			&i.Request,
			&i.Response,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIToolInvocationsByUser = `-- name: ListAIToolInvocationsByUser :many
SELECT id, user_id, provider_id, tool_name, status, request, response, error_message, created_at
FROM ai_tool_invocations
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAIToolInvocationsByUserParams struct {
	UserID uuid.NullUUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListAIToolInvocationsByUser(ctx context.Context, arg ListAIToolInvocationsByUserParams) ([]AiToolInvocation, error) {
	rows, err := q.db.QueryContext(ctx, listAIToolInvocationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiToolInvocation
	for rows.Next() {
		var i AiToolInvocation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProviderID,
			&i.ToolName,
			&i.Status,
			&i.Request,
			&i.Response,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchAIProviderCredential = `-- name: TouchAIProviderCredential :exec
UPDATE ai_provider_credentials
SET last_used_at = now(),
    updated_at   = now()
WHERE company_id = $1
  AND user_id IS NOT DISTINCT FROM $2
  AND provider_id = $3
`

type TouchAIProviderCredentialParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.NullUUID
	ProviderID string
}

func (q *Queries) TouchAIProviderCredential(ctx context.Context, arg TouchAIProviderCredentialParams) error {
	_, err := q.db.ExecContext(ctx, touchAIProviderCredential, arg.CompanyID, arg.UserID, arg.ProviderID)
	return err
}

const touchAIProviderCredentialByID = `-- name: TouchAIProviderCredentialByID :exec
UPDATE ai_provider_credentials
SET last_used_at = now(),
    updated_at   = now()
WHERE id = $1
`

func (q *Queries) TouchAIProviderCredentialByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, touchAIProviderCredentialByID, id)
	return err
}

const updateAIProviderCredential = `-- name: UpdateAIProviderCredential :one
UPDATE ai_provider_credentials
SET
    credential_cipher = COALESCE($1, credential_cipher),
    credential_hash   = COALESCE($2, credential_hash),
    metadata          = COALESCE($3, metadata),
    label             = COALESCE($4, label),
    is_default        = COALESCE($5, is_default),
    last_tested_at    = COALESCE($6, last_tested_at),
    updated_at        = now(),
    rotated_at        = CASE
        WHEN $1 IS NOT NULL
             AND $1 IS DISTINCT FROM credential_cipher THEN now()
        ELSE rotated_at
    END
WHERE id = $7
RETURNING id, company_id, user_id, provider_id, credential_cipher, credential_hash, metadata, created_at, updated_at, last_used_at, rotated_at, label, is_default, last_tested_at, fingerprint
`

type UpdateAIProviderCredentialParams struct {
	CredentialCipher []byte
	CredentialHash   []byte
	Metadata         pqtype.NullRawMessage
	Label            sql.NullString
	IsDefault        sql.NullBool
	LastTestedAt     sql.NullTime
	ID               uuid.UUID
}

func (q *Queries) UpdateAIProviderCredential(ctx context.Context, arg UpdateAIProviderCredentialParams) (AiProviderCredential, error) {
	row := q.db.QueryRowContext(ctx, updateAIProviderCredential,
		arg.CredentialCipher,
		arg.CredentialHash,
		arg.Metadata,
		arg.Label,
		arg.IsDefault,
		arg.LastTestedAt,
		arg.ID,
	)
	var i AiProviderCredential
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.CredentialCipher,
		&i.CredentialHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
		&i.RotatedAt,
		&i.Label,
		&i.IsDefault,
		&i.LastTestedAt,
		&i.Fingerprint,
	)
	return i, err
}

const upsertAIUserPreference = `-- name: UpsertAIUserPreference :one
INSERT INTO ai_user_preferences (company_id, user_id, provider_id, model, metadata)
VALUES ($1, $2, $3, $4, COALESCE($5, '{}'::jsonb))
ON CONFLICT (company_id, user_id) DO UPDATE
SET provider_id = EXCLUDED.provider_id,
    model       = EXCLUDED.model,
    metadata    = EXCLUDED.metadata,
    updated_at  = now()
RETURNING user_id, company_id, provider_id, model, metadata, updated_at
`

type UpsertAIUserPreferenceParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
	Model      sql.NullString
	Column5    interface{}
}

func (q *Queries) UpsertAIUserPreference(ctx context.Context, arg UpsertAIUserPreferenceParams) (AiUserPreference, error) {
	row := q.db.QueryRowContext(ctx, upsertAIUserPreference,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.Model,
		arg.Column5,
	)
	var i AiUserPreference
	err := row.Scan(
		&i.UserID,
		&i.CompanyID,
		&i.ProviderID,
		&i.Model,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}
