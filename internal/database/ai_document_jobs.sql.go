// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ai_document_jobs.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const deleteAIDocumentJob = `-- name: DeleteAIDocumentJob :exec
DELETE FROM ai_document_jobs
WHERE id = $1
  AND company_id = $2
`

type DeleteAIDocumentJobParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) DeleteAIDocumentJob(ctx context.Context, arg DeleteAIDocumentJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIDocumentJob, arg.ID, arg.CompanyID)
	return err
}

const getAIDocumentJob = `-- name: GetAIDocumentJob :one
SELECT id, company_id, user_id, provider_id, status, request, response, error_message, created_at, updated_at, completed_at
FROM ai_document_jobs
WHERE id = $1
  AND company_id = $2
`

type GetAIDocumentJobParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) GetAIDocumentJob(ctx context.Context, arg GetAIDocumentJobParams) (AiDocumentJob, error) {
	row := q.db.QueryRowContext(ctx, getAIDocumentJob, arg.ID, arg.CompanyID)
	var i AiDocumentJob
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.Status,
		&i.Request,
		&i.Response,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const insertAIDocumentJob = `-- name: InsertAIDocumentJob :one
INSERT INTO ai_document_jobs (
    company_id,
    user_id,
    provider_id,
    status,
    request
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, 'queued'),
    $5
)
RETURNING id, company_id, user_id, provider_id, status, request, response, error_message, created_at, updated_at, completed_at
`

type InsertAIDocumentJobParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
	Column4    interface{}
	Request    json.RawMessage
}

func (q *Queries) InsertAIDocumentJob(ctx context.Context, arg InsertAIDocumentJobParams) (AiDocumentJob, error) {
	row := q.db.QueryRowContext(ctx, insertAIDocumentJob,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.Column4,
		arg.Request,
	)
	var i AiDocumentJob
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.Status,
		&i.Request,
		&i.Response,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listAIDocumentJobsByCompany = `-- name: ListAIDocumentJobsByCompany :many
SELECT id, company_id, user_id, provider_id, status, request, response, error_message, created_at, updated_at, completed_at
FROM ai_document_jobs
WHERE company_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAIDocumentJobsByCompanyParams struct {
	CompanyID uuid.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) ListAIDocumentJobsByCompany(ctx context.Context, arg ListAIDocumentJobsByCompanyParams) ([]AiDocumentJob, error) {
	rows, err := q.db.QueryContext(ctx, listAIDocumentJobsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiDocumentJob
	for rows.Next() {
		var i AiDocumentJob
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ProviderID,
			&i.Status,
			&i.Request,
			&i.Response,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAIDocumentJobResponse = `-- name: UpdateAIDocumentJobResponse :exec
UPDATE ai_document_jobs
SET response     = $3,
    status       = 'completed',
    updated_at   = now(),
    completed_at = now()
WHERE id = $1
  AND company_id = $2
`

type UpdateAIDocumentJobResponseParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
	Response  pqtype.NullRawMessage
}

func (q *Queries) UpdateAIDocumentJobResponse(ctx context.Context, arg UpdateAIDocumentJobResponseParams) error {
	_, err := q.db.ExecContext(ctx, updateAIDocumentJobResponse, arg.ID, arg.CompanyID, arg.Response)
	return err
}

const updateAIDocumentJobStatus = `-- name: UpdateAIDocumentJobStatus :exec
UPDATE ai_document_jobs
SET status        = $3,
    error_message = $4,
    updated_at    = now(),
    completed_at  = CASE WHEN $3 IN ('completed', 'failed') THEN now() ELSE completed_at END
WHERE id = $1
  AND company_id = $2
`

type UpdateAIDocumentJobStatusParams struct {
	ID           uuid.UUID
	CompanyID    uuid.UUID
	Status       string
	ErrorMessage sql.NullString
}

func (q *Queries) UpdateAIDocumentJobStatus(ctx context.Context, arg UpdateAIDocumentJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAIDocumentJobStatus,
		arg.ID,
		arg.CompanyID,
		arg.Status,
		arg.ErrorMessage,
	)
	return err
}
