// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ai_conversations.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createAIConversationSession = `-- name: CreateAIConversationSession :one
INSERT INTO ai_conversation_sessions (
    company_id,
    user_id,
    provider_id,
    title,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    COALESCE($5, '{}'::jsonb)
)
RETURNING id, company_id, user_id, provider_id, title, metadata, created_at, updated_at
`

type CreateAIConversationSessionParams struct {
	CompanyID  uuid.UUID
	UserID     uuid.UUID
	ProviderID string
	Title      sql.NullString
	Column5    interface{}
}

func (q *Queries) CreateAIConversationSession(ctx context.Context, arg CreateAIConversationSessionParams) (AiConversationSession, error) {
	row := q.db.QueryRowContext(ctx, createAIConversationSession,
		arg.CompanyID,
		arg.UserID,
		arg.ProviderID,
		arg.Title,
		arg.Column5,
	)
	var i AiConversationSession
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.ProviderID,
		&i.Title,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAIConversationMessagesForSession = `-- name: DeleteAIConversationMessagesForSession :exec
DELETE FROM ai_conversation_messages
WHERE session_id = $1
`

func (q *Queries) DeleteAIConversationMessagesForSession(ctx context.Context, sessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAIConversationMessagesForSession, sessionID)
	return err
}

const deleteAIConversationSession = `-- name: DeleteAIConversationSession :exec
DELETE FROM ai_conversation_sessions
WHERE id = $1
  AND company_id = $2
`

type DeleteAIConversationSessionParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) DeleteAIConversationSession(ctx context.Context, arg DeleteAIConversationSessionParams) error {
	_, err := q.db.ExecContext(ctx, deleteAIConversationSession, arg.ID, arg.CompanyID)
	return err
}

const insertAIConversationMessage = `-- name: InsertAIConversationMessage :one
INSERT INTO ai_conversation_messages (
    session_id,
    role,
    content,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, '{}'::jsonb)
)
RETURNING id, session_id, role, content, metadata, created_at
`

type InsertAIConversationMessageParams struct {
	SessionID uuid.UUID
	Role      string
	Content   string
	Column4   interface{}
}

func (q *Queries) InsertAIConversationMessage(ctx context.Context, arg InsertAIConversationMessageParams) (AiConversationMessage, error) {
	row := q.db.QueryRowContext(ctx, insertAIConversationMessage,
		arg.SessionID,
		arg.Role,
		arg.Content,
		arg.Column4,
	)
	var i AiConversationMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listAIConversationMessages = `-- name: ListAIConversationMessages :many
SELECT id, session_id, role, content, metadata, created_at
FROM ai_conversation_messages
WHERE session_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListAIConversationMessages(ctx context.Context, sessionID uuid.UUID) ([]AiConversationMessage, error) {
	rows, err := q.db.QueryContext(ctx, listAIConversationMessages, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiConversationMessage
	for rows.Next() {
		var i AiConversationMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIConversationSessionsByCompany = `-- name: ListAIConversationSessionsByCompany :many
SELECT id, company_id, user_id, provider_id, title, metadata, created_at, updated_at
FROM ai_conversation_sessions
WHERE company_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAIConversationSessionsByCompanyParams struct {
	CompanyID uuid.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) ListAIConversationSessionsByCompany(ctx context.Context, arg ListAIConversationSessionsByCompanyParams) ([]AiConversationSession, error) {
	rows, err := q.db.QueryContext(ctx, listAIConversationSessionsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiConversationSession
	for rows.Next() {
		var i AiConversationSession
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.ProviderID,
			&i.Title,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAIConversationSessionTitle = `-- name: UpdateAIConversationSessionTitle :exec
UPDATE ai_conversation_sessions
SET title = $3,
    updated_at = now()
WHERE id = $1
  AND company_id = $2
`

type UpdateAIConversationSessionTitleParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
	Title     sql.NullString
}

func (q *Queries) UpdateAIConversationSessionTitle(ctx context.Context, arg UpdateAIConversationSessionTitleParams) error {
	_, err := q.db.ExecContext(ctx, updateAIConversationSessionTitle, arg.ID, arg.CompanyID, arg.Title)
	return err
}
