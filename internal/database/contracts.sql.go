// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contracts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createContract = `-- name: CreateContract :one
INSERT INTO contracts (
    Company_ID,
    Customer_ID,
    Start_Date,
    End_Date,
    Is_Final,
    Contract_URL
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url
`

type CreateContractParams struct {
	CompanyID   uuid.UUID
	CustomerID  uuid.UUID
	StartDate   time.Time
	EndDate     time.Time
	IsFinal     bool
	ContractUrl sql.NullString
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, createContract,
		arg.CompanyID,
		arg.CustomerID,
		arg.StartDate,
		arg.EndDate,
		arg.IsFinal,
		arg.ContractUrl,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartDate,
		&i.EndDate,
		&i.IsFinal,
		&i.ContractUrl,
	)
	return i, err
}

const deleteContract = `-- name: DeleteContract :exec
DELETE FROM contracts
WHERE ID = $1
AND Company_ID = $2
`

type DeleteContractParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) DeleteContract(ctx context.Context, arg DeleteContractParams) error {
	_, err := q.db.ExecContext(ctx, deleteContract, arg.ID, arg.CompanyID)
	return err
}

const getAllContractsCompany = `-- name: GetAllContractsCompany :many
SELECT id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url FROM contracts
WHERE Company_ID = $1
`

func (q *Queries) GetAllContractsCompany(ctx context.Context, companyID uuid.UUID) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, getAllContractsCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.IsFinal,
			&i.ContractUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllcontracts = `-- name: GetAllcontracts :many
SELECT id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url FROM contracts
`

func (q *Queries) GetAllcontracts(ctx context.Context) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, getAllcontracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.IsFinal,
			&i.ContractUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContract = `-- name: GetContract :one
SELECT id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url FROM contracts
WHERE ID = $1
AND Company_ID = $2
`

type GetContractParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) GetContract(ctx context.Context, arg GetContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, getContract, arg.ID, arg.CompanyID)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartDate,
		&i.EndDate,
		&i.IsFinal,
		&i.ContractUrl,
	)
	return i, err
}

const getContractsByCustomer = `-- name: GetContractsByCustomer :many
SELECT id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url FROM contracts
WHERE Company_ID = $1
AND Customer_ID = $2
`

type GetContractsByCustomerParams struct {
	CompanyID  uuid.UUID
	CustomerID uuid.UUID
}

func (q *Queries) GetContractsByCustomer(ctx context.Context, arg GetContractsByCustomerParams) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, getContractsByCustomer, arg.CompanyID, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.IsFinal,
			&i.ContractUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFinalContractsCompany = `-- name: GetFinalContractsCompany :many
SELECT id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url FROM contracts
WHERE Company_ID = $1
AND Is_Final = TRUE
`

func (q *Queries) GetFinalContractsCompany(ctx context.Context, companyID uuid.UUID) ([]Contract, error) {
	rows, err := q.db.QueryContext(ctx, getFinalContractsCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CustomerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.IsFinal,
			&i.ContractUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetcontracts = `-- name: Resetcontracts :exec
Delete FROM contracts
`

func (q *Queries) Resetcontracts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetcontracts)
	return err
}

const updateContract = `-- name: UpdateContract :one
UPDATE contracts
SET
    Customer_ID = $1,
    Start_Date = $2,
    End_Date = $3,
    Is_Final = $4,
    Contract_URL = $5
WHERE ID = $6
AND Company_ID = $7
RETURNING id, company_id, customer_id, created_at, updated_at, start_date, end_date, is_final, contract_url
`

type UpdateContractParams struct {
	CustomerID  uuid.UUID
	StartDate   time.Time
	EndDate     time.Time
	IsFinal     bool
	ContractUrl sql.NullString
	ID          uuid.UUID
	CompanyID   uuid.UUID
}

func (q *Queries) UpdateContract(ctx context.Context, arg UpdateContractParams) (Contract, error) {
	row := q.db.QueryRowContext(ctx, updateContract,
		arg.CustomerID,
		arg.StartDate,
		arg.EndDate,
		arg.IsFinal,
		arg.ContractUrl,
		arg.ID,
		arg.CompanyID,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartDate,
		&i.EndDate,
		&i.IsFinal,
		&i.ContractUrl,
	)
	return i, err
}
