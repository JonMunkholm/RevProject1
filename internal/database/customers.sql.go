// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (Customer_Name, Company_ID)
VALUES (
    $1,
    $2
)
RETURNING id, customer_name, created_at, updated_at, is_active, company_id
`

type CreateCustomerParams struct {
	CustomerName string
	CompanyID    uuid.UUID
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer, arg.CustomerName, arg.CompanyID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.CompanyID,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE ID = $1
AND Company_ID = $2
`

type DeleteCustomerParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) DeleteCustomer(ctx context.Context, arg DeleteCustomerParams) error {
	_, err := q.db.ExecContext(ctx, deleteCustomer, arg.ID, arg.CompanyID)
	return err
}

const getAllCustomers = `-- name: GetAllCustomers :many
SELECT id, customer_name, created_at, updated_at, is_active, company_id FROM customers
`

func (q *Queries) GetAllCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getAllCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.CompanyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCustomersCompany = `-- name: GetAllCustomersCompany :many
SELECT id, customer_name, created_at, updated_at, is_active, company_id FROM customers
WHERE Company_ID = $1
`

func (q *Queries) GetAllCustomersCompany(ctx context.Context, companyID uuid.UUID) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getAllCustomersCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.CompanyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, customer_name, created_at, updated_at, is_active, company_id FROM customers
WHERE ID = $1
AND Company_ID = $2
`

type GetCustomerParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, arg.ID, arg.CompanyID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.CompanyID,
	)
	return i, err
}

const resetCustomers = `-- name: ResetCustomers :exec
Delete FROM customers
`

func (q *Queries) ResetCustomers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetCustomers)
	return err
}
